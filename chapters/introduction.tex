% !TEX encoding = UTF-8 Unicode
%!TEX root = main.tex
% !TEX spellcheck = en-US
%%=========================================

\chapter{Introduction}
\label{ch:introduction}

The notion of concurrency in programming has existed since the 60's. Concurrency regarding computing means multiple computations that are executed in an overlapping fashion, giving the impression that multiple computations are advancing at the same time. This allows programmers to intuitively implement systems which express parallelism natively. Useful and powerful concepts such as semaphores, monitors and threads forms its basis on concurrency. However, new potential challenges such as deadlocks, livelocks and race conditions also comes with concurrency.

For the programmer, the use of concurrency in programs is an added mental overhead. This is mostly as a result of the error prone nature of concurrent programming, and how a small and trivial bug in a program can almost be impossible to find. As a result, many programmers choose other simpler paradigms to avoid this added overhead.

The introduction of \textit{Communicating Sequential Processes} (CSP) by Tony Hoare \citep{csp} formed a whole new basis within concurrent computing. CSP is on its own a formal language, which describes concurrent systems by defining independent processes, communicating only through message-passing. Not only is CSP a powerful tool to describe concurrent systems, but is also a tool to analyze and check the correctness of concurrent systems. 

For concurrent programming, CSP has proven to be a powerful tool. Programs using CSP abstractions follows a more stricter ruleset, creating more correct concurrent systems. This follows from CSP inherently being race condition free. CSP also allows concurrent system to be analyzed, such as proving specification refinement, as well as absence of deadlocks and livelocks.

CSP has influenced the design of multiple programming languages, such as occam, XC and Go. Many of these programming languages have sadly never received the mainstream popularity it deserved, mostly from being proprietary or the lack of use of CSP in the industry. The exception here is Go, which has risen in popularity the last few years. This lack of mainstream CSP programming languages, both in use and availability, has resulted in the development of multiple libraries for more popular languages and compilers of existing CSP languages. This includes JCSP \citep{jcsp}, C++CSP2 \citep{c++csp2}, SPoC \citep{spoc}, KRoC \citep{kroc}, and CCSP \citep{ccsp}. But as this list shows, there does not exist a fully fledged framework enabling CSP abstractions in C programs, that is both feature rich and mature for modern use.

This report introduces and describes the concurrency library ProXC, which enables use of CSP abstraction in C programs. Chapter \ref{ch:introduction} briefly explains the motivation for using CSP abstractions, and the lack of frameworks for enabling CSP abstractions in C programs. Chapter \ref{ch:background} goes more in depth in related concepts and existing work in concurrency programming and the CSP paradigm. Chapter \ref{ch:evaluation} assesses the different approaches for creating a CSP abstraction, and concludes with creating a library. Chapter \ref{ch:proxc_library} introduces ProXC the library, including the complete set of features, target platform and influences. Chapter \ref{ch:design_implementation} details the design and implementation of the library. Chapter \ref{ch:examples_usage} presents examples of code, showcasing the different library features. Chapter \ref{ch:performance} briefly compares benchmarks of the library compared to other existing CSP languages. Chapter \ref{ch:discussion} discusses how the library compares as a CSP abstraction, limitations, and what should have been done differently during development. Chapter \ref{ch:future_work} discusses possible future work for this project. Chapter \ref{ch:conclusion} concludes the report.

