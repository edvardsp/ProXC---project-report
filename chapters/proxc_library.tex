% !TEX encoding = UTF-8 Unicode
%!TEX root = main.tex
% !TEX spellcheck = en-US
%%=========================================

\chapter{ProXC - The Library}
\label{ch:proxc_library}

This chapter will go into further details on what basis ProXC is formed from. Details regarding library design and implementation are explained in Chapter \ref{ch:design} and \ref{ch:implementation}, respectively. 


\section{Introduction to ProXC}
\label{sec:proxc_intro}

ProXC is a CSP\hyp{}inspired concurrency library for C. The library enables C programs to be decomposed into independent sequential processes, and allows the concurrent execution order of said processes to be specified. Communication and synchronization between processes can be strictly lim\-ited to message passing. Message passing is implemented as channels, and are synch\-ronous, pseudo\hyp{}typed, bi\hyp{}directional, and any\hyp{}to\hyp{}any. Alternation between multiple alternatives is possible, and the alternatives can be guarded on a boolean condition. Alternatives consists of channel reads, timeouts and skip. 

ProXC aims to achieve the following goals:
\begin{itemize}[topsep=0em,itemsep=-1em,partopsep=-1em,parsep=1em]
    \item Enabling CSP paradigms in C programs
    \item Acceptable performance
    \item Intuitive and modular API
    \item No use of macro magic in API
    \item Low memory footprint
    \item Low run\hyp{}time overhead
\end{itemize}

The idea with ProXC is the ease of use and simple to incorporate in new and existing C programs. This means the library should not introduce a large number of keywords, macros and functions to be able to use the library. The amount of interactions with ProXC should be minimal, and the programmer should not know the implementation details of the introduced data types and functions. This is why no macro magic is used when interfacing with ProXC. 

ProXC is \textit{not} a hand\hyp{}holding tool for programmers. All existing problems with C, such as NULL pointer dereferencing, memory leaks, pointer aliasing, and much more, is still possible when using ProXC. One can even disregard the CSP model and use global variables instead of message passing. ProXC will not complain. However, ProXC aims to ensure that when a program faults, the origin of the problem is not the library, but the programmer. 

The name ProXC, pronounced ``\textit{prox\hyp{}sea}'', is an abbreviation of ``\textit{Programming XC}''. The name is inspired by the CSP language XC (Section \ref{sssec:xc}). Since XC is a CSP programming language, as well as a superset of C, ProXC makes a fitting name for a CSP library for C. 

\section{Target Platform}
\label{sec:proxc_target_platform}

ProXC currently only supports 32\hyp{}bit and 64\hyp{}bit x86 Linux platforms. This is mainly due to the implementation of context switching in user\hyp{}threads, which requires hand\hyp{}written assembly. Porting to other platforms should not be a difficult task, and is discussed in Section \ref{sec:portability}

\section{Library Features}
\label{sec:proxc_features}

The complete set of features for ProXC is as follows:
\begin{itemize}
    \setlength\itemsep{0em}
    \item User\hyp{}threaded lightweight processes
    \item Run\hyp{}time system running a scheduler
    \item Composite processes of sequential and parallel execution sequence
    \item Synchronous or asynchronous execution of composite processes
    \item Bi\hyp{}directional, pseudo\hyp{}typed, any\hyp{}to\hyp{}any channels
    \item Alternation on multiple alternatives, consisting of channel reads, timeouts and skip
    \item Alternatives guarded by a boolean condition
    \item Implicit and explicit co\hyp{}operative scheduling, through agreed scheduling points or\\ a \texttt{YIELD} command
    \item Suspension of processes for a relative timeout, granularity of microseconds
\end{itemize}

\section{API Design}

FIXME API

